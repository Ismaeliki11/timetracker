import { supabase } from './supabase';
import { Space, TimeEntry } from '../types';

// The user's schema uses text IDs (for compatibility with localStorage 'Date.now()' IDs)
// and composite primary keys (id, user_id).
// RLS ensures we only access our own data.

// Map DB Entry to App Entry
const mapEntryFromDB = (dbEntry: any): TimeEntry => ({
    id: dbEntry.id,
    spaceId: dbEntry.space_id,
    date: dbEntry.date,
    duration: Number(dbEntry.duration), // 'duration' is numeric in DB
    description: dbEntry.description || '',
    tags: dbEntry.tags || [],
    icon: dbEntry.icon
});

// Map App Entry to DB Entry
const mapEntryToDB = (entry: Omit<TimeEntry, 'id'> & { id?: string }, userId: string) => ({
    id: entry.id, // We must provide ID if it's not auto-generated by DB. User schema has 'id text not null', so we must provide it.
    user_id: userId,
    space_id: entry.spaceId,
    date: entry.date,
    duration: entry.duration,
    description: entry.description,
    tags: entry.tags,
    icon: entry.icon
});

// Map DB Space to App Space
const mapSpaceFromDB = (dbSpace: any): Space => ({
    id: dbSpace.id,
    name: dbSpace.name,
    color: dbSpace.color,
    icon: dbSpace.icon
});

export const dataService = {
    // --- SPACES ---
    async getSpaces() {
        const { data, error } = await supabase
            .from('spaces')
            .select('*')
            .order('created_at', { ascending: true });

        if (error) throw error;
        return (data || []).map(mapSpaceFromDB);
    },

    async createSpace(space: Space) {
        // Note: We expect 'space' to already have an ID (generated by App or here).
        // App currently generates IDs (Date.now()).
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) throw new Error("No user logged in");

        const { data, error } = await supabase
            .from('spaces')
            .insert({
                id: space.id,
                user_id: user.id,
                name: space.name,
                color: space.color,
                icon: space.icon
            })
            .select()
            .single();

        if (error) throw error;
        return mapSpaceFromDB(data);
    },

    async updateSpace(id: string, updates: Partial<Space>) {
        const { data, error } = await supabase
            .from('spaces')
            .update({
                name: updates.name,
                color: updates.color,
                icon: updates.icon
            })
            .eq('id', id)
            // RLS handles user matching
            .select()
            .single();

        if (error) throw error;
        return mapSpaceFromDB(data);
    },

    async deleteSpace(id: string) {
        const { error } = await supabase
            .from('spaces')
            .delete()
            .eq('id', id);

        if (error) throw error;
    },

    async upsertSpace(space: Space) {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) throw new Error("No user logged in");

        const { data, error } = await supabase
            .from('spaces')
            .upsert({
                id: space.id,
                user_id: user.id,
                name: space.name,
                color: space.color,
                icon: space.icon
            })
            .select()
            .single();

        if (error) throw error;
        return mapSpaceFromDB(data);
    },

    // --- TIME ENTRIES ---
    async getTimeEntries() {
        const { data, error } = await supabase
            .from('time_entries')
            .select('*')
            .order('date', { ascending: false }); // Latest first

        if (error) throw error;
        return (data || []).map(mapEntryFromDB);
    },

    async createTimeEntry(entry: TimeEntry) {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) throw new Error("No user logged in");

        const { data, error } = await supabase
            .from('time_entries')
            .insert(mapEntryToDB(entry, user.id))
            .select()
            .single();

        if (error) throw error;
        return mapEntryFromDB(data);
    },

    async updateTimeEntry(id: string, updates: Partial<TimeEntry>) {
        // Construct update object
        const dbUpdates: any = {};
        if (updates.spaceId) dbUpdates.space_id = updates.spaceId;
        if (updates.date) dbUpdates.date = updates.date;
        if (updates.duration !== undefined) dbUpdates.duration = updates.duration;
        if (updates.description !== undefined) dbUpdates.description = updates.description;
        if (updates.tags) dbUpdates.tags = updates.tags;
        if (updates.icon) dbUpdates.icon = updates.icon;

        const { data, error } = await supabase
            .from('time_entries')
            .update(dbUpdates)
            .eq('id', id)
            .select()
            .single();

        if (error) throw error;
        return mapEntryFromDB(data);
    },

    async deleteTimeEntry(id: string) {
        const { error } = await supabase
            .from('time_entries')
            .delete()
            .eq('id', id);

        if (error) throw error;
    },

    async upsertTimeEntry(entry: TimeEntry) {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) throw new Error("No user logged in");

        const { data, error } = await supabase
            .from('time_entries')
            .upsert(mapEntryToDB(entry, user.id))
            .select()
            .single();

        if (error) throw error;
        return mapEntryFromDB(data);
    }
};
